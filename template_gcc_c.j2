/**
{%- set SM = statemachine|upper %}
{%- set sm = statemachine|lower %}
 * Generated by program - do not edit
 *
 * Statemachine Engine
 */
#include "{{sm}}.fsm.h"
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#define {{SM}}_NUM_STATES {{states|count}}
#define {{SM}}_NUM_EVENTS {{events|count}}
#define {{SM}}_NUM_ACTIONS {{actions|count}}

/* Actions */
struct {{SM}}_ACTION_t {
    int index;
    char *name;
};

enum {
{%- for action in actions|sort(case_sensitive=True) %}
    e{{SM}}_ACTION_{{action}} = {{loop.index}},
{%- endfor %}
};
{% for action in actions|sort(case_sensitive=True) %}
static const struct {{SM}}_ACTION_t s{{SM}}_ACTION_{{action}} = {e{{SM}}_ACTION_{{action}}, "{{action}}"};
{%- endfor %}
{% for action in actions|sort(case_sensitive=True) %}
const {{SM}}_ACTION {{SM}}_ACTION_{{action}} = &s{{SM}}_ACTION_{{action}};
{%- endfor %}

static const struct {{SM}}_ACTION_t *{{SM}}_ACTION_table[] = {
    NULL,
{%- for action in actions|sort(case_sensitive=True) %}
    &s{{SM}}_ACTION_{{action}},
{%- endfor %}
};

/* Events */
struct {{SM}}_EVENT_t {
    int index;
    char *name;
};

enum {
{%- for event in events|sort(case_sensitive=True) %}
    e{{SM}}_EVENT_{{event}} = {{loop.index}},
{%- endfor %}
};
{% for event in events|sort(case_sensitive=True) %}
static const struct {{SM}}_EVENT_t s{{SM}}_EVENT_{{event}} = {e{{SM}}_EVENT_{{event}}, "{{event}}"};
{%- endfor %}
{% for event in events|sort(case_sensitive=True) %}
const {{SM}}_EVENT {{SM}}_EVENT_{{event}} = &s{{SM}}_EVENT_{{event}};
{%- endfor %}

static const struct {{SM}}_EVENT_t * const {{SM}}_EVENT_table[] = {
    NULL,
{%- for event in events|sort(case_sensitive=True) %}
    &s{{SM}}_EVENT_{{event}},
{%- endfor %}
};

/* States */
enum {
{%- for state in states|sort(case_sensitive=True) %}
    e{{SM}}_STATE_{{state}} = {{loop.index}},
{%- endfor %}
};

/* Transaction Table Structures */
typedef struct fsmTransTab_t {
    int inState;        /* Input State */
    int inEvent;        /* Input Event */
    int outState;       /* Output State */
    int actList[{{SM}}_NUM_ACTIONS+1];     /* Action Funcs */
    int outEvents[{{SM}}_NUM_EVENTS+1];    /* Output Events */
} fsmTransTab;

/* Transaction Table Entries */
{%- for state in transactions|sort(case_sensitive=True) %}
{%- for event in transactions[state]|sort(case_sensitive=True) %}
const static fsmTransTab {{SM}}_TRANS_{{state}}_{{event}} = {
    .inState=e{{SM}}_STATE_{{state}},
    .inEvent=e{{SM}}_EVENT_{{event}},
{%- if transactions[state][event].states|count > 0 %}
    .outState=e{{SM}}_STATE_{{transactions[state][event].states|first}},
{%- else %}
    .outState=0,
{%- endif %}
    .actList= {
{%- for action in transactions[state][event].actions %}
        e{{SM}}_ACTION_{{ action }},
{%- endfor %}
        0},
    .outEvents= {
{%- for target in transactions[state][event].events %}
        e{{SM}}_EVENT_{{ target }},
{%- endfor %}
        0}
};
{%- endfor %}
{%- endfor %}

/* State Data */
struct {{SM}}_STATE_t {
    int index;
    const char *name;
    const fsmTransTab *transTab[];
};
{% for state in states|sort(case_sensitive=True) %}
static struct {{SM}}_STATE_t const s{{SM}}_STATE_{{state}} = {
    .index=e{{SM}}_STATE_{{state}},
    .name="{{state}}",
    .transTab={
        NULL,
{%- for event in events|sort(case_sensitive=True) %}
{%- if transactions[state][event] is defined %}
        &{{SM}}_TRANS_{{state}}_{{event}},
{%- else %}
        NULL, /* {{SM}}_TRANS_{{state}}_{{event}} */
{%- endif %}
{%- endfor %}
    }
};
{%- endfor %}
{% for state in states|sort(case_sensitive=True) %}
const {{SM}}_STATE {{SM}}_STATE_{{state}} = &s{{SM}}_STATE_{{state}};
{%- endfor %}
static struct {{SM}}_STATE_t const * const {{SM}}_STATE_table[] = {
    NULL,
{%- for state in states|sort(case_sensitive=True) %}
    &s{{SM}}_STATE_{{state}},
{%- endfor %}
    NULL
};
static {{SM}}_Action action_funcs[{{SM}}_NUM_ACTIONS+1];

/* State Machine Class */
typedef struct fsmStateMachine_t fsmStateMachine;
struct fsmStateMachine_t {
    char *name;
    int numStates;
    int numEvents;
    int numActions;
    const {{SM}}_STATE *stateTable;
    const {{SM}}_EVENT *eventTable;
    const {{SM}}_ACTION *actionTable;
    {{SM}}_EVENT entryEvent;
    {{SM}}_EVENT exitEvent;
    {{SM}}_Action *actionTab; /* Class Actions */
};

/* Event Queue Entry */
typedef struct EventQueueEntry_t {
    struct EventQueueEntry_t *next;
    {{SM}}_EVENT ev;
    void *pContext;
} *pQueueEntry;

/* State Machine Instance */
struct {{SM}}_t {
    char *name;
    const fsmStateMachine *fsm;
    {{SM}}_Action *actionTab; /* Instance Actions */
    {{SM}}_STATE currentState;
    void (*reportFunc)({{SM}} smi, const char *fmt, ...);
    void *pPrivate; /* private */
    void (*pKiller)(void*);
    bool BusyFlag;
    struct {
        pQueueEntry pHead;
        pQueueEntry pTail;
        int iLength;
    } EventQueue, EmptyQueue;
};

/* State Machine Initializer */
static const fsmStateMachine fsm_{{SM|lower}} = {
    .name="{{SM|lower}}",
    .numStates={{SM}}_NUM_STATES,
    .numEvents={{SM}}_NUM_EVENTS,
    .numActions={{SM}}_NUM_ACTIONS,
    .stateTable={{SM}}_STATE_table,
    .eventTable={{SM}}_EVENT_table,
    .actionTable={{SM}}_ACTION_table,
    .entryEvent=&s{{SM}}_EVENT_Entry,
    .exitEvent=&s{{SM}}_EVENT_Exit,
    .actionTab=action_funcs
};

/*
 * Create an Instance of this Statemachine
 */
{{SM}} {{SM}}_InstanceMake(const char *name, {{SM}}_STATE initial)
{
    {{SM}} smi = ({{SM}}) calloc(1, sizeof(struct {{SM}}_t));
    if (smi == NULL)
        return NULL;
    /* TODO initialisation */
    smi->name = strdup(name);
    smi->fsm = &fsm_{{SM|lower}};
    smi->currentState = initial;
    return smi;
}

/*
 * Force the Instance into the given State
 */
void {{SM}}_ForceState({{SM}} smi, {{SM}}_STATE initial)
{
    if (smi)
        smi->currentState = initial;
}

/*
 * Destroy an Instance of this Statemachine
 */
void {{SM}}_InstanceKill({{SM}} smi)
{
    if (smi == NULL)
        return;
    free(smi->name);
    if (smi->actionTab)
        free(smi->actionTab);
    if (smi->pPrivate && smi->pKiller)
        (*smi->pKiller)(smi->pPrivate);
    while (smi->EmptyQueue.pHead) {
        pQueueEntry entry;
        entry = smi->EmptyQueue.pHead;
        smi->EmptyQueue.pHead = smi->EmptyQueue.pHead->next;
        free(entry);
    }
    free(smi);
}

/**
 * Run an Event for the current State in this Instance of the Statemachine
 *
 * For this event in the current state run all of the actions.
 * If any action returns a new event then stop doing actions
 * and switch to that event and begin its actions.
 *
 * This allows an action to classify a generic event to a specific event
 * or for an action to raise an exception event.
 *
 * @param   smi        the statemachine instance
 * @param   ev         the event to process
 * @param   pContext   the event context data
 * @return             the old/new state
 */
static {{SM}}_STATE {{SM}}_RunStateEvent(
    {{SM}} smi,
    {{SM}}_EVENT ev,
    void *pContext)
{
    const fsmStateMachine *fsm = smi->fsm;
    {{SM}}_STATE state = smi->currentState;
    {{SM}}_EVENT event = NULL;
    const fsmTransTab *tab;
    int i;
    /*
     * For this event and each new generated event
     */
    while (ev) {
        /*
         * Get the transaction table entry for this event in the current state
         */
        tab = state->transTab[ev->index];
        if (tab == NULL) {
            /*
             * No table entry means Default action
             */
            if (smi->reportFunc)
                (*smi->reportFunc)(smi, "%s(%s) [<unhandled>]",
                                   state->name, ev->name);
            if (state->transTab[e{{SM}}_EVENT_Default]) {
                /* TODO: Check Default */
                ev = {{SM}}_EVENT_Default;
                event = NULL;
                continue;
            }
            return state;
        }
        if (tab->actList[0] == 0) {
            /* No Actions */
            if (smi->reportFunc) {
                (*smi->reportFunc)(smi, "%s(%s) [<no actions>]",
                                   state->name, ev->name);
            }
            if (tab->outState) {
                return fsm->stateTable[tab->outState];
            }
            return state;
        }
        /*
         * Perform each action in the action list
         */
        for (i = 0; tab->actList[i]; ++i) {
            {{SM}}_Action fn;
            int k;
            k = tab->actList[i];
            /*
             * Prefer the instance action (if any) to the state machine action
             */
            if (smi->actionTab && smi->actionTab[k])
                fn = smi->actionTab[k];
            else
                fn = fsm->actionTab[k];
            /*
             * Report the action
             */
            if (smi->reportFunc)
                (*smi->reportFunc)(smi, "%s(%s) -> %s",
                                   state->name, ev->name, fsm->actionTable[k]->name);
            /*
             * Invoke the action
             */
            event = (*fn)(smi, state, ev, pContext, smi->pPrivate);
            /*
             * If the action returns a new event then stop doing actions
             */
            if (event) {
                /* TODO: check this event is allowed */
                break;
            }
        }
        ev = NULL;
        if (event) {
            /* This is a new (classifier or exception) event */
            ev = event;
            event = NULL;
            continue;
        }
        if (tab->outState) {
            return fsm->stateTable[tab->outState];
        }
    }
    return state;
}

/**
 * Run an event through the statemachine instance
 *
 * If the statemachine is busy processing an event then queue the event.
 * This can happen if an action routine sends an event either directly,
 * as a result of calling a funtion, or from sending an event to another
 * statemachine.
 *
 * If there is another event queued when we complete this event then we
 * process that event before we return.
 *
 * @param smi       the statemachine instance
 * @param ev        the event to process
 * @param pContext  private event context
 * @return          Nothing
 */
void {{SM}}_ProcessEvent({{SM}} smi, {{SM}}_EVENT ev, void *pContext)
{
    pQueueEntry event;
    if (smi->BusyFlag) {
        /*
         * This instance is busy with an event
         * get an empty event queue item
         */
        if (smi->EmptyQueue.pHead) {
            /*
             * Pop an empty off the Empty Queue
             */
            event = smi->EmptyQueue.pHead;
            --smi->EmptyQueue.iLength;
            smi->EmptyQueue.pHead = event->next;
            if (smi->EmptyQueue.pHead == NULL)
                smi->EmptyQueue.pTail = NULL;
            else
                event->next = NULL;
        } else {
            /*
             * allocate and initialize a new empty
             */
            event = calloc(1, sizeof(struct EventQueueEntry_t));
            /* TODO: check return */
            if (smi->reportFunc)
                (*smi->reportFunc)(smi,
                                   "new event queue entry in %s(%s)",
                                   smi->currentState->name,
                                   ev->name);
        }
        /*
         * Put the new event on the Event Queue
         */
        event->ev = ev;
        event->pContext = pContext;
        if (smi->EventQueue.pHead) {
            /* push this event on the tail and return */
            smi->EventQueue.pTail->next = event;
            smi->EventQueue.pTail = event;
        } else {
            /* push this event on the queue and continue */
            smi->EventQueue.pHead = smi->EventQueue.pTail = event;
        }
        ++smi->EventQueue.iLength;
        if (smi->reportFunc)
            (*smi->reportFunc)(smi, "recursive event in %s is %s",
                               smi->currentState->name,
                               ev->name);
        return;
    }
    smi->BusyFlag = true;
    do {
        {{SM}}_STATE next_state = {{SM}}_RunStateEvent(smi, ev, pContext);
        while (next_state != smi->currentState) {
            if (smi->fsm->exitEvent)
                {{SM}}_RunStateEvent(smi, smi->fsm->exitEvent, pContext);
            if (smi->reportFunc)
                (*smi->reportFunc)(smi,
                    "%s ==> %s",
                    smi->currentState->name,
                    next_state->name);
            smi->currentState = next_state;
            if (smi->fsm->entryEvent)
                next_state = {{SM}}_RunStateEvent(smi, smi->fsm->entryEvent, pContext);
        }
        ev = NULL;
        if (smi->EventQueue.pHead == NULL)
            break;
        /*
         * pop the next event off the Event Queue
         */
        event = smi->EventQueue.pHead;
        smi->EventQueue.pHead = event->next;
        if (smi->EventQueue.pHead == NULL)
            smi->EventQueue.pTail = NULL;
        --smi->EventQueue.iLength;
        ev = event->ev;
        pContext = event->pContext;
        /*
         * push current event onto the Empty Queue
         */
        if (smi->EmptyQueue.pHead) {
            smi->EmptyQueue.pTail->next = event;
            smi->EmptyQueue.pTail = event;
        } else {
            smi->EmptyQueue.pHead = smi->EmptyQueue.pTail = event;
        }
        ++smi->EmptyQueue.iLength;
    } while (ev);
    smi->BusyFlag = false;
}

void {{SM}}_ClassSetAction(
        {{SM}}_ACTION action,
        {{SM}}_Action func)
{
    if (action->index > 0 && action->index <= {{SM}}_NUM_ACTIONS)
        action_funcs[action->index] = func;
}

void {{SM}}_InstanceSetAction(
        {{SM}} smi,
        {{SM}}_ACTION action,
        {{SM}}_Action func)
{
    if (action->index > 0 && action->index <= {{SM}}_NUM_ACTIONS) {
        if (smi->actionTab == NULL)
            smi->actionTab = ({{SM}}_Action *) calloc({{SM}}_NUM_ACTIONS + 1, sizeof({{SM}}_Action));
        smi->actionTab[action->index] = func;
    }
}

/* Report Function accessors */
void {{SM}}_SetReportFunc({{SM}} smi,
    void (*reportFunc)({{SM}} smi, const char *fmt, ...))
{
    smi->reportFunc = reportFunc;
}
void (*{{SM}}_GetReportFunc({{SM}} smi))({{SM}} smi, const char *fmt, ...)
{
    return smi->reportFunc;
}

/* Private data accessors */
void {{SM}}_SetPrivate({{SM}} smi, void *data, void (*pKiller)(void *))
{
    smi->pPrivate = data;
    smi->pKiller = pKiller;
}
void *{{SM}}_GetPrivate({{SM}} smi)
{
    return smi->pPrivate;
}
const char *{{SM}}_GetName({{SM}} smi)
{
    return smi->name;
}

#ifdef UNIT_TEST
{%- for action in actions|sort %}
static {{SM}}_EVENT {{SM}}_ACTION_{{action}}_test(
        {{SM}} smi,
        {{SM}}_STATE state,
        {{SM}}_EVENT event,
        void *pContext,
        void *pPrivate)
{
    printf("State: %-20s, Event: %-20s, ActionFunc: {{action}}\n", state->name, event->name);
    return NULL;
}

{%- endfor %}

static void register_{{sm}}_actions(void)
{
{%- for action in actions|sort %}
    {{SM}}_ClassSetAction({{SM}}_ACTION_{{action}}, {{SM}}_ACTION_{{action}}_test);
{%- endfor %}
}

static void test_{{sm}}_actions(void)
{
    {{SM}} smi;
    const fsmTransTab *tab = NULL;
    int state;
    int event;
    int idx;
    register_{{sm}}_actions();

    smi = {{SM}}_InstanceMake("test", {{SM}}_STATE_ST_ConnectIdle);
    /* For each state */
    for (state = 1; state <= {{SM}}_NUM_STATES; ++state) {
        printf("State: %s\n", {{SM}}_STATE_table[state]->name);
        /* For each event */
        for (event = 1; event <= {{SM}}_NUM_EVENTS; ++event) {
            /*
             * Set the starting state
             */
            smi->currentState = {{SM}}_STATE_table[state];
            /*
             * Run this event
             */
            {{SM}}_ProcessEvent(smi, {{SM}}_EVENT_table[event], NULL);
            /*
             * Print the result
             */
            tab = {{SM}}_STATE_table[state]->transTab[event];
            if (tab) {
                if (smi->currentState->index != state)
                    printf("       %s ===> %s\n", {{SM}}_STATE_table[state]->name, smi->currentState->name);
            }
        }
    }
    {{SM}}_InstanceKill(smi);
}

static void fsmPrintStateMachine(void)
{
    const fsmTransTab *tab = NULL;
    int state;
    int event;
    int action;

    printf("Statemachine {{SM}}\n");
    /* For each state */
    for (state = 1; state <= {{SM}}_NUM_STATES; ++state) {
        printf("  State: %s\n", {{SM}}_STATE_table[state]->name);
        /* For each event */
        for (event = 1; event <= {{SM}}_NUM_EVENTS; ++event) {
            tab = {{SM}}_STATE_table[state]->transTab[event];
            if (tab) {
                printf("    Event: %s : <%s>\n",
                       {{SM}}_EVENT_table[event]->name,
                       tab->outState ?  {{SM}}_STATE_table[tab->outState]->name : "");
                for (action = 1; action <= {{SM}}_NUM_ACTIONS; ++action) {
                    if (tab->actList[action] == 0)
                        break;
                    printf("      Action: %s\n", {{SM}}_ACTION_table[action]->name);
                }
            }
        }
    }
}

int main(int argc, char *argv[])
{
    fsmPrintStateMachine();
    test_{{sm}}_actions();
}

#endif /* UNIT_TEST */

/*
 * vim{# This spoils vim #}: ft=c ts=8 sts=4 sw=4 et cindent
 {#- vim: ft=jinja ts=8 sts=4 sw=4 et smartindent nocindent
 #}
 */
