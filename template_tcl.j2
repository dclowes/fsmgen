{%- set SM = statemachine|upper -%}
{%- set sm = statemachine|lower -%}
# Generated by template
#
# This file contains the generated runtime for the
# "{{SM}}" state machine.
#
# It should not be modified.
#
#------------------------------------------------------------------------------
# Run one event through the state machine and return a tupple -
#     next_state: state to transition to next (default: this)
#     next_event: event to inject next (default: none)
#     rule_count: number of rules invoked (0 or 1)
#
proc StateSwitch_{{sm}} {context state event} {
    set next_state ${state}
    set next_event {}

    # Handle the given event in the given state performing all actions
    # unless one returns an exception/classifier event
{%- for state in states|sort(case_sensitive=True) if transactions[state] is defined %}
    if {${state} == "{{state}}"} {

{%- for event in events|sort(case_sensitive=True) if transactions[state][event] is defined %}
        if {${event} == "{{event}}"} {
  {%- for action in transactions[state][event]['actions'] %}
            set next_event [{{action}} ${context} ${state} ${event}]
            if {${next_event} != {}} {
              return [list ${next_state} ${next_event} 1]
            }
  {%- endfor %}
  {%- if transactions[state][event]['states']|count > 0 %}
            set next_state "{{transactions[state][event]['states']|first}}"
  {%- endif %}
            return [list ${next_state} ${next_event} 1]
        }
{%- endfor %}
        return [list ${next_state} ${next_event} 0]
    }
{%- endfor %}
    return [list ${next_state} ${next_event} 0]
}

#------------------------------------------------------------------------------
# Run this event through the state machine and any events produced by
# any of the actions processed and return a tupple -
#     next_state: state to transition to next (default: this)
#     next_event: event to inject next (should be: none)
#     rule_count: number of rules invoked
#
proc RunStateSwitch_{{sm}} {context state event} {
    set next_state ${state}
    set next_event ${event}
    set rule_count 0
    while { ${next_event} != {} } {
        set state_event [StateSwitch_{{sm}} ${context} ${state} ${next_event}]
{%- if 'SCT' in outputs %}
        debug_log ${context} 1 "StateSwitch ${context} ${state} ${next_event} => ${state_event}"
{%- endif %}
        set next_state [lindex ${state_event} 0]
        set next_event [lindex ${state_event} 1]
        set rule_count [expr {${rule_count} + [lindex ${state_event} 2]}]
        if { ${next_event} != {} } {
            continue
        }
        if { ${next_state} != ${state} } {
            set state_event [StateSwitch_{{sm}} ${context} ${state} "Exit"]
{%- if 'SCT' in outputs %}
            debug_log ${context} 1 "StateSwitch ${context} ${state} Exit => ${state_event}"
{%- endif %}
            set state_event [StateSwitch_{{sm}} ${context} ${next_state} "Entry"]
{%- if 'SCT' in outputs %}
            debug_log ${context} 1 "StateSwitch ${context} ${next_state} Entry => ${state_event}"
{%- endif %}
        }
        set state ${next_state}
    }
    return [list ${next_state} ${next_event} ${rule_count}]
}

# vim{# vim: set ft=jinja ts=8 sw=4 sts=4 et :#}: ft=tcl ts=8 sw=4 sts=4 et
